// Code generated by command: go run calcAttacks.go -out attacks_amd64.s -stubs attacks_amd64.go. DO NOT EDIT.

#include "textflag.h"

DATA bytes<>+0(SB)/8, $0x0f0f0f0f0f0f0f0f
DATA bytes<>+8(SB)/8, $0x0f0f0f0f0f0f0f0f
DATA bytes<>+16(SB)/8, $0x0e060a020c040800
DATA bytes<>+24(SB)/8, $0x0f070b030d050901
DATA bytes<>+32(SB)/8, $0xe060a020c0408000
DATA bytes<>+40(SB)/8, $0xf070b030d0509010
DATA bytes<>+48(SB)/8, $0x0001020304050607
DATA bytes<>+56(SB)/8, $0x08090a0b0c0d0e0f
GLOBL bytes<>(SB), RODATA|NOPTR, $64

// func queenAttacks(occupied uint64, location uint64, rank uint64, file uint64, diag uint64, antidiag uint64) uint64
// Requires: AVX, SSE2, SSE3, SSE4.1
TEXT ·queenAttacks(SB), NOSPLIT, $0-56
	MOVQ occupied+0(FP), AX
	MOVQ location+8(FP), CX
	MOVQ rank+16(FP), DX
	MOVQ file+24(FP), BX
	MOVQ diag+32(FP), SI
	MOVQ antidiag+40(FP), DI
	LEAQ bytes<>+0(SB), R8

	// Load Constants
	MOVAPD (R8), X1
	MOVAPD 16(R8), X2
	MOVAPD 32(R8), X3
	MOVAPD 48(R8), X0

	// Load Masks
	MOVQ   SI, X4
	MOVQ   DI, X5
	MOVQ   DX, X6
	MOVQ   BX, X7
	SHUFPD $0x00, X6, X4
	SHUFPD $0x00, X7, X5

	// Prep position vars
	MOVQ    CX, X10
	MOVDDUP X10, X10
	MOVAPD  X10, X9
	PSLLQ   $0x01, X9

	// Prep data vars
	MOVQ    AX, X6
	MOVDDUP X6, X6
	MOVAPD  X6, X7
	PAND    X4, X6
	PAND    X5, X7

	// Subtract first half
	VPSUBQ X9, X6, X8
	VPSUBQ X9, X6, X9

	// Reverse pos
	VPAND   X1, X10, X11
	VPANDN  X10, X1, X10
	VPSRLD  $0x04, X10, X10
	VPSHUFB X11, X3, X11
	VPSHUFB X10, X2, X10
	VPOR    X10, X11, X10
	VPSHUFB X0, X10, X10

	// Shift pos
	PSLLQ $0x01, X10

	// Reverse dataL
	VPAND   X1, X6, X11
	VPANDN  X6, X1, X6
	VPSRLD  $0x04, X6, X6
	VPSHUFB X11, X3, X11
	VPSHUFB X6, X2, X6
	VPOR    X6, X11, X6
	VPSHUFB X0, X6, X6

	// Reverse dataR
	VPAND   X1, X7, X11
	VPANDN  X7, X1, X7
	VPSRLD  $0x04, X7, X7
	VPSHUFB X11, X3, X11
	VPSHUFB X7, X2, X7
	VPOR    X7, X11, X7
	VPSHUFB X0, X7, X7

	// Subtract second half
	VPSUBQ X10, X6, X6
	VPSUBQ X10, X7, X7

	// Unreverse dataL
	VPAND   X1, X6, X10
	VPANDN  X6, X1, X6
	VPSRLD  $0x04, X6, X6
	VPSHUFB X10, X3, X10
	VPSHUFB X6, X2, X6
	VPOR    X6, X10, X6
	VPSHUFB X0, X6, X6

	// Unreverse dataR
	VPAND   X1, X7, X10
	VPANDN  X7, X1, X7
	VPSRLD  $0x04, X7, X7
	VPSHUFB X10, X3, X10
	VPSHUFB X7, X2, X7
	VPOR    X7, X10, X7
	VPSHUFB X0, X7, X7

	// Finish
	PXOR X8, X6
	PXOR X9, X7
	PAND X4, X6
	PAND X5, X7
	PXOR X0, X0
	POR  X6, X0
	POR  X7, X0

	// Extract
	PEXTRQ $0x01, X0, AX
	MOVQ   X0, CX
	ORQ    AX, CX
	MOVQ   CX, ret+48(FP)
	RET

// func bishopRookAttacks(occupied uint64, location uint64, rankOrDiag uint64, fileOrAntiDiag uint64) uint64
// Requires: AVX, SSE2, SSE3, SSE4.1
TEXT ·bishopRookAttacks(SB), NOSPLIT, $0-40
	MOVQ occupied+0(FP), AX
	MOVQ location+8(FP), CX
	MOVQ rankOrDiag+16(FP), DX
	MOVQ fileOrAntiDiag+24(FP), BX
	LEAQ bytes<>+0(SB), SI

	// Load Constants
	MOVAPD (SI), X1
	MOVAPD 16(SI), X2
	MOVAPD 32(SI), X3
	MOVAPD 48(SI), X0

	// Load Masks
	MOVQ   DX, X4
	MOVQ   BX, X5
	SHUFPD $0x00, X5, X4

	// Prep position vars
	MOVQ    CX, X7
	MOVDDUP X7, X7
	MOVAPD  X7, X6
	PSLLQ   $0x01, X6

	// Prep data vars
	MOVQ    AX, X5
	MOVDDUP X5, X5
	PAND    X4, X5

	// Subtract first half
	VPSUBQ X6, X5, X6

	// Reverse pos
	VPAND   X1, X7, X8
	VPANDN  X7, X1, X7
	VPSRLD  $0x04, X7, X7
	VPSHUFB X8, X3, X8
	VPSHUFB X7, X2, X7
	VPOR    X7, X8, X7
	VPSHUFB X0, X7, X7

	// Shift pos
	PSLLQ $0x01, X7

	// Reverse data
	VPAND   X1, X5, X8
	VPANDN  X5, X1, X5
	VPSRLD  $0x04, X5, X5
	VPSHUFB X8, X3, X8
	VPSHUFB X5, X2, X5
	VPOR    X5, X8, X5
	VPSHUFB X0, X5, X5

	// Subtract second half
	VPSUBQ X7, X5, X5

	// Unreverse data
	VPAND   X1, X5, X7
	VPANDN  X5, X1, X5
	VPSRLD  $0x04, X5, X5
	VPSHUFB X7, X3, X7
	VPSHUFB X5, X2, X5
	VPOR    X5, X7, X5
	VPSHUFB X0, X5, X5

	// Finish
	PXOR X6, X5
	PAND X4, X5

	// Extract
	PEXTRQ $0x01, X5, AX
	MOVQ   X5, CX
	ORQ    AX, CX
	MOVQ   CX, ret+32(FP)
	RET
